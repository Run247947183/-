#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#if 0
int main(){
	int a[] = { 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24 };
	int* q[4];
	int k;
	for (k = 0; k < 4; ++k){
		q[k] = &a[k * 3];
	}
	printf("%d\n", q[3][1]);
	system("pause");
	return 0;
}
int main(){
	int i = 0;
	int j = 0;
	int a = 0;
	for (i = 0; i < 2; ++i){
		for (j = 2; j < 4; ++j){
			if (j % 2){
				break;
			}
			++a;
		}
		++a;
	}
	printf("%d\n", a);
	system("pause");
	return 0;
}

int ma(){
	int i = 0;
	for (i = 1; i <= 10; ++i){
		if (i == 5){
			break;
		}
		printf("%d\n", i);
	}
	system("pause");
	return 0;
}


//二维数组中，每一行按照从左到右递增的顺序排序，每一列按照从上到下递增的顺序排序
//完成一个函数，输入这样的二维数组和一个整数
//判断数组中是否含有该整数，时间复杂度0（row+col)

//例如：  1  2  3
       // 2  4  5
	   // 6  8  9
//这种题找左下角和右上角的数字作为依据，这样遇到比他俩大或者小的数，可以做出选择


void Find_Num(int arr[3][3], int num){
	int i=0;
	int j=2;
	while (1){
		if (num > arr[i][j] && i < 3){
			++i;
		}
		else if (num < arr[i][j] && j < 3){
			--j;
		}
		else if (num==arr[i][j]) {
			printf("找到了！\n");
			break;
		}
		else {
			printf("没找到！\n");
			break;
		}
	}
}


int main(){
	int arr[3][3] = {
		4, 9, 12,
		7, 10, 13,
		8, 11, 15
	};
	Find_Num(arr, 16);
	system("pause");
	return 0;
}
//写一个函数，将字符串中的空格替换为%20
//例如：“abc erf sdf"替换为"abc%20erf%20sdf"
void Replace(char arr[],int size){
	int old_len = strlen(arr);
	int i;
	int new_len;
	int sum = 0;
	for (i = 0; i < old_len; ++i){
		if (arr[i] == ' '){
			++sum;
		}
	}
	 new_len = old_len + sum * 2 ;
	 int p1 = old_len;
	 int p2 = new_len;
	 arr[new_len] = '\0';
	 while (p1>0 && p2 > 0){
		 if (arr[p1] == ' '){
			 arr[p2] = '0';
			 arr[p2 - 1] = '2';
			 arr[p2 - 2] = '%';
			 --p1;
			 p2 = p2 - 3;
		 }
		 else {
			 arr[p2--] = arr[p1--];
		 }
	 }printf("%s\n", arr);
}

int main(){
	char arr[] =  "wo ai zhongguo" ;
	int size = strlen(arr);
	Replace(arr, size); 
	system("pause");
	return 0;
}

int main(){
	int a = 5;
	if (a = 0){
		printf("%d\n", a - 10);
	}
	else {
		printf("%d\n", ++a);
	}
	system("pause");
	return 0;
}

//求第n个斐波那契数列的值

int Fib(int n){
	int i = 0;
	int a = 1;
	int b = 1;
	int ret = 0;
	if (n <= 2){
		return 1;
	}
	else {
		for (i = 0; i <= n; ++i){
			ret = a + b;
			a = b;
			b = ret;
		}
	}
	return ret;
}

int main(){
	int n;
	printf("请输入需要计算的斐波那契数：");
	scanf("%d", &n);
	int ret2 = Fib(n);
	printf("最后结果为%d\n", ret2);
	system("pause");
	return 0;
}
#define F(x,y) ((x)+(y))
int main(){
	int a = 3;
	int b = 4;
	printf("%d\n", F(a++, b++));
	system("pause");
	return 0;
}

int fun(int x, int y){
	static int m = 0;//static在局部变量前，该语句只执行一次，以后使用上一次的结果
	static int i = 2;
	i += m + 1;
	m = i + x + y;
	return m;
}


int main(){
	int j = 4;
	int m = 1;
	int k;
	k = fun(j, m);
	printf("%d\n", k);
	system("pause");
	return 0;
}


//写一个函数，求unsigned int 型变量x在内存中二进制1的个数

int count_one_bits(int n){
	int count = 0;
	while (n){
		n = n&(n - 1);
		++count;
	}
	return count;
}


int main(){
	int n;
	printf("请输入一个数：");
	scanf("%d", &n);
	int ret=count_one_bits(n);
	printf("这个数在内存中二进制1的个数为%d\n",ret);
	system("pause");
	return 0;
}

int change(int* px){
	int y = 8;
	y = y - *px;
	px = &y;
	return 0;
}


int main(){
	int xx = 3;
	int* py = &xx;
	change(py);
	printf("%d\n", *py);
	system("pause");
	return 0;
}

#endif

int main(){
	char arr[2][4];
	strcpy((char*)arr, "you");
	strcpy(arr[1], "me");
	arr[0][3] = '&';
	printf("%s\n", arr);
	system("pause");
	return 0;
}

// 5???
int f(int x){
	int b = 0;
	static int c = 3;
	x = ++c;
	++b;
	return x;
}

int main(){
	int a = 2, i, k;
	for (i = 0; i < 2; ++i){
		k = f(++a);
	}
	printf("%d\n", k);
	system("pause");
	return 0;
}

int main(){
	int m;
	int n = 0;
	for (m = 0, n = -1; n = 0; ++m, ++n){
		++n;
	}
	printf("%d\n", n);
	system("pause");
	return 0;
}

int a = 2;
int test(){
	int a = 2;
	a += 1;
}

int main(){
	test();
	printf("%d\n", a);
	system("pause");
	return 0;
}

int main(){
	int y = 10;
	int x = 0;
	x = y++;
	printf("%d  %d\n", x, y);
	system("pause");
	return 0;
}

int main(){
	int i = 0;
	int j = 0;
	if ((++i > 0) || (++j > 0)){
		printf("i=%d;j=%d\n", i, j);
	}
	system("pause");
	return 0;
}

#define MOD(x,y) x%y
int main(){
	int a = 13;
	int b = 94;
	printf("%d\n", MOD(b, a + 4));
	system("pause");
	return 0;
}
//有一个数组a，编写函数，求数组中前k个最小的数字

void Swap(int* x, int* y){
	int tmp = *x;
	*x = *y;
	*y = tmp;
}

void Find_Min_Num(int a[], int k){
	int bound = 0;
	for (bound = 0; bound < k; ++bound){
		for (int cur = k - 1; cur>bound; --cur){
			if (a[cur - 1] > a[cur]){
				Swap(&a[cur - 1], &a[cur]);//降序
			}
		}
	}
}

int main(){
	int a[] = { 5, 4, 6, 3, 2, 19, 18, 43, 5, 12, 7 };
	int k = 5;
	Find_Min_Num(a, k);
	int ret = a[0];
	printf("最小数字为：%d\n",ret);
	system("pause");
	return 0;
}
?????
int main(){
	char a[] = "abc";
	char b[] = { 'a', 'b', 'c', 'd', 'e', 'f', 'g' };
	printf("%d\n", strlen(a));
	system("pause");
	return 0;
}
//????
int main(){
	int s = 0;
	int n;
	for (n = 0; n < 4; ++n){
		switch (n){
		fedault:
			s += 4;
		case 1:
			s += 1;
		case 2:
			s += 2;
		case 3:
			s += 3;
		}
	}
	printf("%d\n", s);
	system("pause");
	return 0;
}


int main(){
	char* a = "blue1";
	char b[] = "bule1";
	printf("%d", sizeof(b));
	system("pause");
	return 0;
}
#endif
//编写函数：求数组中元素出现次数超过数组长度一半的数字。
//如{1，2，3，2，2，2，5，4，2}数字2为超过数组长度一半的数字

void swap(int* x, int* y){
	int tmp = *x;
	*x = *y;
	*y = tmp;
}

void bubble_sort(int* arr, int len){
	int bound = 0;
	for (bound = 0; bound < len; ++bound){
		for (int cur = len - 1; cur>bound; --cur){
			if (arr[cur - 1] > arr[cur]){
				swap(&arr[cur - 1], &arr[cur]);
			}
		}
	}
}


void Find_Num(int* arr, int len){
	bubble_sort(arr, len);
	int mid_num = arr[len / 2];
	printf("超过数组长度一半的数字为:%d\n",mid_num);
}

int main(){
	int arr[] = { 1, 2, 3, 1, 1, 1 };
	int len = sizeof(arr) / sizeof(arr[0]);
	Find_Num(arr, len);
	system("pause");
	return 0;
}
