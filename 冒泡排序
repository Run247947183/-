#include<stdio.h>
#include<stdlib.h>

void swap(int* x, int* y){
	int tmp = *x;
	*x = *y;
	*y = tmp;
}

void bubble_sort(int *arr, int size){
	//有两种方式1.找最小的排序  2.找最大的排序
	//这里用找最小的排序方法
	//[0,bound)这是已排序区间
	//[bound,0)待排序区间
	for (int bound = 0; bound < size; bound++){
		//此时作用是找到一个比较小的值,并放到合适的位置
		for (int cur = size - 1; cur>bound; cur--){
			//此时作用是完成一趟查找中查找最小的过程
			if (arr[cur-1] > arr[cur]){
				//此处为升序排序
				//意思是如果前一个元素比后一个元素大,说明不符合要求,那就交换这俩元素
				swap(&arr[cur - 1], &arr[cur]);
			}
		}
	}
}

int main(){
	int arr[5] = { 4, 5, 6, 9, 8 };
	int size = sizeof(arr) / sizeof(arr[0]);
	bubble_sort(arr, size);
	for (int i = 0; i < size; i++){
		printf("%d ", arr[i]);
	}printf("\n");
	system("pause");
}

/
#define TableSize 256

char FirstNotRepeatingChar(char* string){
	if (string == NULL){
		return '\0';
	}
	unsigned int hashTable[TableSize];
	for (unsigned int i = 0; i < TableSize; ++i){
		hashTable[i] = 0;
	}
	char* pHashKey = string;
	while (*(pHashKey) != '\0'){
		hashTable[*(pHashKey++)]++;//???????????
	}
	pHashKey = string;
	while (*(pHashKey) != '\0'){
		if (hashTable[*pHashKey] == 1){
			return *pHashKey;
		}
		pHashKey++;
	}
	return '\0';
}

int main(){
	char string[] = "abaccdeff";
	printf("%c\n", FirstNotRepeatingChar(string));
	system("pause");
	return 0;
}
//P249
//题目:数组中的逆序对
//数组中的两个数字，如果前面一个数大于后面的数字，那么这两个数字组成了逆序对
//例如数组{7，5，6，4}中，一共有五个逆序对

//解法一(时间复杂度为O(n的平方))：
int FindReverseOrder(int* arr,int length){
	int i = 0;
	int j = 0;
	int count = 0;
	if (arr == NULL || length <= 0){
		return 0;
	}
	for (j = 0; j < length; ++j){
		int temp = arr[j];
		for (i = j+1; i < length ; ++i){
			if (temp > arr[i]){
				++count;
			}
		}
	}
	return count;
}

int main(){
	int str[] = { 7, 5, 6, 4 };
	int len = sizeof(str) / sizeof(str[0]);
	int ret = FindReverseOrder(str, len);
	if (ret == 0){
		printf("对不起，您输入的数组有误！\n");
	}
	else {
		printf("该数组有逆序对：%d\n",ret);
	}
	system("pause");
	return 0;
}

//解法二：

//P264
//题目：在排序数组中查找数字
//统计一个数字在数组出现的次数，例如数组{1，2，3，3，3，3，4，5}中3的出现了4次，输出3

//解法一(时间复杂度为O(n)):二分查找

int FindNumFrequency(int* str, int length,int num){
	int count = 0;
	int left = 0;
	int right = length - 1;
	int mid = 0;
	if (str == NULL || length <= 0){
		return 0;
	}
	while (left <= right){
		mid = (left + right) >> 1;
		if (str[mid] == num){
			++count;
			++mid;
		}
		else if (str[mid]>num) {
			right = mid - 1;
		}
		else{
			left = mid + 1;
		}
	}
}

#endif

//解法二：

int GetFirstNum(const int* str, int length, int left, int right, int num){
	if (left > right){
		return -1;
	}
	int mid_length = (left + right) >> 1;
	int mid_str = str[mid_length];
	if (mid_str == num){
		//这种情况是中间元素为num，然后再判断这个数是不是第一个num
		if ((mid_length > 0 && str[mid_length - 1] != num )|| mid_length == 0){
			//如果为下标0，那么它一定是第一个num
			//如果下标不为0，并且前一个数也不为num，又因为是按顺序排列，那么它一定为第一个num
			return mid_length;
		}
		else{
			//既然它不为第一个num，那么第一个num一定在它的左边
			right = mid_length - 1;
		}
	}
	else if (mid_str > num){
		right = mid_length - 1;
	}
	else {
		left = mid_length + 1;
	}
	return GetFirstNum(str, length, left, right, num);//次情况说明没有找到第一个num，递归接着查找第一个num
}

int GetLastNum(const int* str, int length, int left, int right, int num){
	if (left > right){
		return -1;
	}
	int mid_length = (left + right) >> 1;
	int mid_str = str[mid_length];
	if (mid_str == num){
		if ((mid_length < length - 1 && str[mid_length + 1] != num )|| mid_length == length - 1){
			//如果下标等于该数组的最后一个下表，那么它一定为最后一个num
			//如果下标不为该数组的最后一个下标，并且它的后一个元素不为num，那么它也一定为最后一个num
			return mid_length;
		}
		else{
			left = mid_length + 1;
		}
	}
	else if (mid_str < num){
		left = mid_length + 1;
	}
	else {
		right = mid_length - 1;
	}
	return GetLastNum(str, length, left, right, num);
}

